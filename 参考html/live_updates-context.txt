====================
Directory Tree (selected)
====================

live_updates/
├── .dart_tool/
│   ├── extension_discovery/
│   │   ├── devtools.json
│   │   └── vs_code.json
│   └── package_config.json
├── android/
│   ├── .gradle/
│   │   ├── 9.0-milestone-1/
│   │   │   ├── checksums/
│   │   │   │   ├── md5-checksums.bin
│   │   │   │   └── sha1-checksums.bin
│   │   │   ├── fileChanges/
│   │   │   │   └── last-build.bin
│   │   │   └── gc.properties
│   │   ├── buildOutputCleanup/
│   │   │   └── cache.properties
│   │   ├── vcs-1/
│   │   │   └── gc.properties
│   │   └── config.properties
│   ├── src/
│   │   ├── main/
│   │   │   ├── kotlin/
│   │   │   │   └── com/
│   │   │   │       └── yours/
│   │   │   │           └── live_updates/
│   │   │   │               ├── LiveUpdateManager.kt
│   │   │   │               ├── LiveUpdatesPlugin.kt
│   │   │   │               ├── NotificationClickReceiver.kt
│   │   │   │               └── NotificationForegroundService.kt
│   │   │   ├── res/
│   │   │   │   └── layout/
│   │   │   │       ├── custom_callstyle_notification.xml
│   │   │   │       ├── custom_notification.xml
│   │   │   │       ├── custom_notification_image.xml
│   │   │   │       ├── custom_notification_layout.xml
│   │   │   │       ├── custom_notification_progress.xml
│   │   │   │       ├── custom_notification_scrolling_text.xml
│   │   │   │       └── custom_notification_text.xml
│   │   │   └── AndroidManifest.xml
│   │   └── test/
│   │       └── kotlin/
│   │           └── com/
│   │               └── example/
│   │                   └── live_updates/
│   │                       └── LiveUpdatesPluginTest.kt
│   ├── .gitignore
│   ├── build.gradle
│   ├── live_updates_android.iml
│   ├── local.properties
│   └── settings.gradle
├── lib/
│   ├── models/
│   │   ├── live_update_progress_view.dart
│   │   ├── live_update_style_provider.dart
│   │   └── live_update_view.dart
│   ├── live_updates.dart
│   ├── live_updates_method_channel.dart
│   └── live_updates_platform_interface.dart
├── test/
│   ├── live_updates_method_channel_test.dart
│   └── live_updates_test.dart
├── .gitignore
├── .metadata
├── CHANGELOG.md
├── LICENSE
├── README.md
├── analysis_options.yaml
├── live_updates.iml
└── pubspec.yaml

--------------------
File: /live_updates/android/src/main/kotlin/com/yours/live_updates/LiveUpdateManager.kt
--------------------

package com.yours.live_updates

import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.graphics.BitmapFactory
import android.os.Build
import android.widget.RemoteViews
import androidx.core.app.NotificationCompat
import androidx.core.app.Person
import android.net.Uri
import android.app.Person as AndroidPerson
import android.graphics.drawable.Icon
import android.media.session.MediaSession
import android.graphics.drawable.AdaptiveIconDrawable
import android.graphics.drawable.BitmapDrawable
import com.yours.live_updates.NotificationForegroundService

class LiveUpdateManager(private val context: Context) {

    private val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

    companion object {
        const val CHANNEL_ID = "live_updates_channel"
        private const val CHANNEL_NAME = "Live Updates"
    }

    fun initialize() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(CHANNEL_ID, CHANNEL_NAME, NotificationManager.IMPORTANCE_HIGH).apply {
                description = "Channel for live updates notifications"
                enableLights(true)
                enableVibration(true)
                setSound(android.provider.Settings.System.DEFAULT_NOTIFICATION_URI, null)
                lockscreenVisibility = NotificationChannel.VISIBILITY_PUBLIC
                setShowBadge(true)
            }
            notificationManager.createNotificationChannel(channel)
        }
    }

    fun showCustomNotification(
        notificationId: Int,
        title: String,
        text: String,
        ongoing: Boolean,
        autoCancel: Boolean,
        views: List<Map<String, Any>>,
        payload: String? = null
    ) {
        val remoteViews = RemoteViews(context.packageName, R.layout.custom_notification)

        for (view in views) {
            when (view["type"]) {
                "textView" -> {
                    val textView = RemoteViews(context.packageName, R.layout.custom_notification_text)
                    textView.setTextViewText(R.id.custom_text, view["text"] as String)
                    remoteViews.addView(R.id.custom_notification_container, textView)
                }
                "scrollingTextView" -> {
                    val scrollingTextView = RemoteViews(context.packageName, R.layout.custom_notification_scrolling_text)
                    scrollingTextView.setTextViewText(R.id.custom_scrolling_text, view["text"] as String)
                    remoteViews.addView(R.id.custom_notification_container, scrollingTextView)
                }
                "imageView" -> {
                    val imageView = RemoteViews(context.packageName, R.layout.custom_notification_image)
                    val imageBytes = view["image"] as? ByteArray
                    if (imageBytes != null) {
                        val bitmap = BitmapFactory.decodeByteArray(imageBytes, 0, imageBytes.size)
                        imageView.setImageViewBitmap(R.id.custom_image, bitmap)
                        remoteViews.addView(R.id.custom_notification_container, imageView)
                    }
                }
            }
        }

        // Create a pending intent for notification click with payload
        val intent = Intent(context, NotificationClickReceiver::class.java).apply {
            putExtra("payload", payload)
        }
        val pendingIntent = PendingIntent.getBroadcast(
            context,
            notificationId,
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        val builder = NotificationCompat.Builder(context, CHANNEL_ID)
            .setContentTitle(title)
            .setContentText(text)
            .setSmallIcon(android.R.drawable.ic_dialog_info)
            .setOngoing(ongoing)
            .setAutoCancel(autoCancel)
            .setCustomContentView(remoteViews)
            .setCustomBigContentView(remoteViews) // Add this for expanded view
            .setContentIntent(pendingIntent)
            .setPriority(NotificationCompat.PRIORITY_MAX)
            .setDefaults(NotificationCompat.DEFAULT_ALL) // Add default sound, vibration, and lights
            .setCategory(NotificationCompat.CATEGORY_CALL) // Use CALL category for highest priority
            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC) // Show on lock screen
            .setSound(android.provider.Settings.System.DEFAULT_NOTIFICATION_URI)

        // Always set fullScreenIntent for heads-up notification
        val fullScreenIntent = context.packageManager.getLaunchIntentForPackage(context.packageName)
        if (fullScreenIntent != null) {
            fullScreenIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP)
            fullScreenIntent.putExtra("payload", payload)
            val fullScreenPendingIntent = PendingIntent.getActivity(
                context,
                notificationId,
                fullScreenIntent,
                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
            )
            builder.setFullScreenIntent(fullScreenPendingIntent, true)
        }

        notificationManager.notify(notificationId, builder.build())
    }

    fun showNotification(
        title: String,
        text: String,
        notificationId: Int,
        ongoing: Boolean,
        autoCancel: Boolean,
        subText: String?,
        category: String?,
        fullScreen: Boolean,
        largeIcon: ByteArray?,
        progress: Int?,
        progressMax: Int?,
        progressIndeterminate: Boolean,
        shortCriticalText: String? = null,
        whenTimestamp: Long? = null,
        payload: String? = null
    ) {
        // Create a pending intent for notification click with payload
        val intent = Intent(context, NotificationClickReceiver::class.java).apply {
            putExtra("payload", payload)
        }
        val pendingIntent = PendingIntent.getBroadcast(
            context,
            notificationId,
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        val builder = NotificationCompat.Builder(context, CHANNEL_ID)
            .setContentTitle(title)
            .setContentText(text)
            .setSmallIcon(android.R.drawable.ic_dialog_info)
            .setOngoing(ongoing)
            .setAutoCancel(autoCancel)
            .setContentIntent(pendingIntent)
            .setPriority(NotificationCompat.PRIORITY_MAX)
            .setDefaults(NotificationCompat.DEFAULT_ALL) // Add default sound, vibration, and lights
            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC) // Show on lock screen
            .setSound(android.provider.Settings.System.DEFAULT_NOTIFICATION_URI)
            .setCategory(category ?: NotificationCompat.CATEGORY_CALL) // Use CALL category for highest priority if not specified
            
        // Set short critical text for status chip if provided
        if (shortCriticalText != null && Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {
            builder.extras.putString("android.shortcriticaltext", shortCriticalText)
        }
        
        // Set when timestamp if provided
        if (whenTimestamp != null) {
            builder.setWhen(whenTimestamp)
            builder.setShowWhen(true)
        }

        if (subText != null) {
            builder.setSubText(subText)
        }

        if (category != null) {
            builder.setCategory(category)
        }

        if (largeIcon != null) {
            val bitmap = BitmapFactory.decodeByteArray(largeIcon, 0, largeIcon.size)
            builder.setLargeIcon(bitmap)
        }

        // Always set fullScreenIntent for heads-up notification
        val launchIntent = context.packageManager.getLaunchIntentForPackage(context.packageName)
        if (launchIntent != null) {
            launchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP)
            launchIntent.putExtra("payload", payload)
            val fullScreenPendingIntent = PendingIntent.getActivity(
                context,
                notificationId,
                launchIntent,
                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
            )
            builder.setFullScreenIntent(fullScreenPendingIntent, true)
        }

        // Apply different styles based on category
        when (category) {
            "call" -> {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                    // Use CallStyle for Android 12+ (API 31+)
                    val person = androidx.core.app.Person.Builder()
                        .setName(title)
                        .build()
                    
                    val launchIntent = context.packageManager.getLaunchIntentForPackage(context.packageName)
                    if (launchIntent != null) {
                        val answerPendingIntent = Intent(context, NotificationClickReceiver::class.java).setAction("ANSWER_CALL").let {
                            PendingIntent.getBroadcast(context, notificationId + 100, it, PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT)
                        }
                        val declinePendingIntent = Intent(context, NotificationClickReceiver::class.java).setAction("DECLINE_CALL").let {
                            PendingIntent.getBroadcast(context, notificationId + 200, it, PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT)
                        }
                        
                        val callStyle = NotificationCompat.CallStyle.forIncomingCall(
                            person,
                            declinePendingIntent,
                            answerPendingIntent
                        )
                        builder.setStyle(callStyle)
                    }
                    
                    // Always set fullScreenIntent for CallStyle notifications to meet Android requirements
                    val fullScreenIntent = context.packageManager.getLaunchIntentForPackage(context.packageName)
                    if (fullScreenIntent != null) {
                        val fullScreenPendingIntent = PendingIntent.getActivity(
                            context,
                            notificationId + 300,
                            fullScreenIntent,
                            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
                        )
                        builder.setFullScreenIntent(fullScreenPendingIntent, true)
                    }
                    
                    // Set high priority and category for call notifications
                    builder.setPriority(NotificationCompat.PRIORITY_HIGH)
                    builder.setCategory(NotificationCompat.CATEGORY_CALL)
                    
                    // Start foreground service for call notifications
                    val serviceIntent = Intent(context, NotificationForegroundService::class.java).apply {
                        putExtra("title", title)
                        putExtra("text", text)
                    }
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                        context.startForegroundService(serviceIntent)
                    } else {
                        context.startService(serviceIntent)
                    }
                }
            }
            "progress" -> {
                if (progress != null && progressMax != null) {
                    builder.setProgress(progressMax, progress, progressIndeterminate)
                    // Use BigTextStyle for progress visualization
                     val progressStyle = NotificationCompat.BigTextStyle()
                         .bigText(text)
                         .setBigContentTitle(title)
                     builder.setStyle(progressStyle)
                }
            }
            else -> {
                // Use BigTextStyle as default
                val bigTextStyle = NotificationCompat.BigTextStyle()
                    .bigText(text)
                    .setBigContentTitle(title)
                builder.setStyle(bigTextStyle)
            }
        }

        if (fullScreen) {
            val fullScreenIntent = context.packageManager.getLaunchIntentForPackage(context.packageName)
            if (fullScreenIntent != null) {
                val fullScreenPendingIntent = PendingIntent.getActivity(
                    context,
                    0,
                    fullScreenIntent,
                    PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
                )
                builder.setFullScreenIntent(fullScreenPendingIntent, true)
            }
        }
        
        notificationManager.notify(notificationId, builder.build())
    }

    fun cancelNotification(notificationId: Int) {
        notificationManager.cancel(notificationId)
    }
}

--------------------
File: /live_updates/android/src/main/kotlin/com/yours/live_updates/LiveUpdatesPlugin.kt
--------------------

package com.yours.live_updates

import com.yours.live_updates.LiveUpdateManager
import io.flutter.embedding.engine.plugins.FlutterPlugin
import io.flutter.plugin.common.MethodCall
import io.flutter.plugin.common.MethodChannel
import io.flutter.plugin.common.MethodChannel.MethodCallHandler
import io.flutter.plugin.common.MethodChannel.Result
import io.flutter.plugin.common.EventChannel
import io.flutter.plugin.common.EventChannel.EventSink
import io.flutter.plugin.common.EventChannel.StreamHandler

/** LiveUpdatesPlugin */
class LiveUpdatesPlugin : FlutterPlugin, MethodCallHandler, StreamHandler {
    private lateinit var channel: MethodChannel
    private lateinit var payloadChannel: EventChannel
    private lateinit var liveUpdateManager: LiveUpdateManager

    companion object {
        private var eventSink: EventSink? = null

        fun sendPayload(payload: String?) {
            eventSink?.success(payload)
        }
    }

    override fun onAttachedToEngine(flutterPluginBinding: FlutterPlugin.FlutterPluginBinding) {
        channel = MethodChannel(flutterPluginBinding.binaryMessenger, "live_updates")
        channel.setMethodCallHandler(this)
        
        payloadChannel = EventChannel(flutterPluginBinding.binaryMessenger, "live_updates/payload")
        payloadChannel.setStreamHandler(this)
        
        liveUpdateManager = LiveUpdateManager(flutterPluginBinding.applicationContext)
        liveUpdateManager.initialize()
    }

    override fun onMethodCall(call: MethodCall, result: Result) {
        when (call.method) {
            "showCustomNotification" -> {
                try {
                    val notificationId = call.argument<Int>("notificationId") ?: 0
                    val title = call.argument<String>("title") ?: ""
                    val text = call.argument<String>("text") ?: ""
                    val ongoing = call.argument<Boolean>("ongoing") ?: false
                    val autoCancel = call.argument<Boolean>("autoCancel") ?: true
                    val views = call.argument<List<Map<String, Any>>>("views") ?: emptyList()
                    val payload = call.argument<String>("payload")

                    liveUpdateManager.showCustomNotification(
                        notificationId,
                        title,
                        text,
                        ongoing,
                        autoCancel,
                        views,
                        payload
                    )
                    result.success(null)
                } catch (e: Exception) {
                    result.error("showCustomNotification_error", e.message, null)
                }
            }
            "showNotification" -> {
                try {
                    val title = call.argument<String>("title") ?: ""
                    val text = call.argument<String>("text") ?: ""
                    val notificationId = call.argument<Int>("notificationId") ?: 0
                    val ongoing = call.argument<Boolean>("ongoing") ?: false
                    val autoCancel = call.argument<Boolean>("autoCancel") ?: true
                    val subText = call.argument<String>("subText")
                    val category = call.argument<String>("category")
                    val fullScreen = call.argument<Boolean>("fullScreen") ?: false
                    val largeIcon = call.argument<ByteArray>("largeIcon")
                    val progress = call.argument<Int>("progress")
                    val progressMax = call.argument<Int>("progressMax")
                    val progressIndeterminate = call.argument<Boolean>("progressIndeterminate") ?: false
                    val shortCriticalText = call.argument<String>("shortCriticalText")
                    val whenTimestamp = call.argument<Long>("whenTimestamp")
                    val payload = call.argument<String>("payload")

                    liveUpdateManager.showNotification(
                        title,
                        text,
                        notificationId,
                        ongoing,
                        autoCancel,
                        subText,
                        category,
                        fullScreen,
                        largeIcon,
                        progress,
                        progressMax,
                        progressIndeterminate,
                        shortCriticalText,
                        whenTimestamp,
                        payload
                    )
                    result.success(null)
                } catch (e: Exception) {
                    result.error("showNotification_error", e.message, null)
                }
            }
            "cancelNotification" -> {
                try {
                    val notificationId = call.argument<Int>("notificationId") ?: 0
                    liveUpdateManager.cancelNotification(notificationId)
                    result.success(null)
                } catch (e: Exception) {
                    result.error("cancelNotification_error", e.message, null)
                }
            }
            else -> {
                result.notImplemented()
            }
        }
    }

    override fun onDetachedFromEngine(binding: FlutterPlugin.FlutterPluginBinding) {
        channel.setMethodCallHandler(null)
        payloadChannel.setStreamHandler(null)
    }
    
    override fun onListen(arguments: Any?, events: EventSink?) {
        eventSink = events
    }
    
    override fun onCancel(arguments: Any?) {
        eventSink = null
    }
}


--------------------
File: /live_updates/android/src/main/kotlin/com/yours/live_updates/NotificationClickReceiver.kt
--------------------

package com.yours.live_updates

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.widget.Toast
import android.app.PendingIntent
import android.os.Build

class NotificationClickReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        // Handle specific actions
        when (intent.action) {
            "ANSWER_CALL" -> {
                // Handle answer call action
                Toast.makeText(context, "Call answered", Toast.LENGTH_SHORT).show()
                // You can also send an event back to Flutter if needed
                val payload = intent.getStringExtra("payload")
                LiveUpdatesPlugin.sendPayload(payload)
            }
            "DECLINE_CALL" -> {
                // Handle decline call action
                Toast.makeText(context, "Call declined", Toast.LENGTH_SHORT).show()
                // You can also send an event back to Flutter if needed
            }
            else -> {
                // Handle regular notification click
                val payload = intent.getStringExtra("payload")
                
                // Launch the app
                val launchIntent = context.packageManager.getLaunchIntentForPackage(context.packageName)
                if (launchIntent != null) {
                    launchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP)
                    // Pass the payload to the app
                    launchIntent.putExtra("payload", payload)
                    context.startActivity(launchIntent)
                }
                
                // Send payload to Flutter
                LiveUpdatesPlugin.sendPayload(payload)
            }
        }
    }
}

--------------------
File: /live_updates/android/src/main/kotlin/com/yours/live_updates/NotificationForegroundService.kt
--------------------

package com.yours.live_updates

import android.app.Notification
import android.app.Service
import android.content.Intent
import android.os.IBinder
import androidx.core.app.NotificationCompat

/**
 * Foreground service for supporting CallStyle notifications
 * This service is required for Android to allow CallStyle notifications
 */
class NotificationForegroundService : Service() {
    companion object {
        const val NOTIFICATION_ID = 9999
    }

    override fun onBind(intent: Intent?): IBinder? {
        return null
    }

    override fun onCreate() {
        super.onCreate()
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        val title = intent?.getStringExtra("title") ?: "Call in progress"
        val text = intent?.getStringExtra("text") ?: "Tap to return to call"
        startForeground(title, text)
        return START_STICKY
    }

    private fun startForeground(title: String, text: String) {
        val notification = NotificationCompat.Builder(this, LiveUpdateManager.CHANNEL_ID)
            .setContentTitle(title)
            .setContentText(text)
            .setSmallIcon(android.R.drawable.ic_dialog_info)
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setCategory(NotificationCompat.CATEGORY_CALL)
            .build()

        startForeground(NOTIFICATION_ID, notification)
    }
}

--------------------
File: /live_updates/android/src/test/kotlin/com/example/live_updates/LiveUpdatesPluginTest.kt
--------------------

package com.yours.live_updates

import io.flutter.plugin.common.MethodCall
import io.flutter.plugin.common.MethodChannel
import kotlin.test.Test
import org.mockito.Mockito

/*
 * This demonstrates a simple unit test of the Kotlin portion of this plugin's implementation.
 *
 * Once you have built the plugin's example app, you can run these tests from the command
 * line by running `./gradlew testDebugUnitTest` in the `example/android/` directory, or
 * you can run them directly from IDEs that support JUnit such as Android Studio.
 */

internal class LiveUpdatesPluginTest {
  @Test
  fun onMethodCall_getPlatformVersion_returnsExpectedValue() {
    val plugin = LiveUpdatesPlugin()

    val call = MethodCall("getPlatformVersion", null)
    val mockResult: MethodChannel.Result = Mockito.mock(MethodChannel.Result::class.java)
    plugin.onMethodCall(call, mockResult)

    Mockito.verify(mockResult).success("Android " + android.os.Build.VERSION.RELEASE)
  }
}


--------------------
File: /live_updates/lib/live_updates.dart
--------------------

import 'dart:async';
import 'dart:typed_data';

import 'package:flutter/services.dart';
import 'package:live_updates/models/live_update_view.dart';

class LiveUpdates {
  static const MethodChannel _channel = MethodChannel('live_updates');
  static const EventChannel _payloadChannel = EventChannel('live_updates/payload');

  static Stream<String?>? _notificationPayloadStream;

  static Stream<String?> get notificationPayloadStream {
    _notificationPayloadStream ??= _payloadChannel.receiveBroadcastStream().map((payload) => payload as String?);
    return _notificationPayloadStream!;
  }

  static Future<void> showCustomNotification({
    required int notificationId,
    required String title,
    required String text,
    bool ongoing = false,
    bool autoCancel = true,
    List<LiveUpdateView> views = const [],
    String? payload,
  }) async {
    final List<Map<String, dynamic>> viewMaps = views.map((v) => v.toMap()).toList();
    await _channel.invokeMethod('showCustomNotification', {
      'notificationId': notificationId,
      'title': title,
      'text': text,
      'ongoing': ongoing,
      'autoCancel': autoCancel,
      'views': viewMaps,
      'payload': payload,
    });
  }

  static Future<void> showNotification({
    required String title,
    required String text,
    required int notificationId,
    bool ongoing = false,
    bool autoCancel = true,
    String? subText,
    String? category,
    bool fullScreen = false,
    Uint8List? largeIcon,
    int? progress,
    int? progressMax,
    bool progressIndeterminate = false,
    String? shortCriticalText,
    DateTime? when,
    String? payload,
  }) async {
    await _channel.invokeMethod('showNotification', {
      'title': title,
      'text': text,
      'notificationId': notificationId,
      'ongoing': ongoing,
      'autoCancel': autoCancel,
      'subText': subText,
      'category': category,
      'fullScreen': fullScreen,
      'largeIcon': largeIcon,
      'progress': progress,
      'progressMax': progressMax,
      'progressIndeterminate': progressIndeterminate,
      'shortCriticalText': shortCriticalText,
      'whenTimestamp': when?.millisecondsSinceEpoch,
      'payload': payload,
    });
  }

  static Future<void> cancelNotification(int notificationId) async {
    await _channel.invokeMethod('cancelNotification', {
      'notificationId': notificationId,
    });
  }
}


--------------------
File: /live_updates/lib/live_updates_method_channel.dart
--------------------

import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';

import 'live_updates_platform_interface.dart';

/// An implementation of [LiveUpdatesPlatform] that uses method channels.
class MethodChannelLiveUpdates extends LiveUpdatesPlatform {
  /// The method channel used to interact with the native platform.
  @visibleForTesting
  final methodChannel = const MethodChannel('live_updates');

  @override
  Future<void> showCustomNotification(Map<String, dynamic> arguments) async {
    await methodChannel.invokeMethod<void>(
        'showCustomNotification', arguments);
  }

  @override
  Future<void> showCustomCallNotification(Map<String, dynamic> arguments) async {
    await methodChannel.invokeMethod<void>('showCustomCallNotification', arguments);
  }

  @override
  Future<void> showNotification(Map<String, dynamic> arguments) async {
    await methodChannel.invokeMethod<void>('showNotification', arguments);
  }

  @override
  Future<void> cancelNotification(Map<String, dynamic> arguments) async {
    await methodChannel.invokeMethod<void>('cancelNotification', arguments);
  }
}


--------------------
File: /live_updates/lib/live_updates_platform_interface.dart
--------------------

import 'package:plugin_platform_interface/plugin_platform_interface.dart';

import 'live_updates_method_channel.dart';

abstract class LiveUpdatesPlatform extends PlatformInterface {
  /// Constructs a LiveUpdatesPlatform.
  LiveUpdatesPlatform() : super(token: _token);

  static final Object _token = Object();

  static LiveUpdatesPlatform _instance = MethodChannelLiveUpdates();

  /// The default instance of [LiveUpdatesPlatform] to use.
  ///
  /// Defaults to [MethodChannelLiveUpdates].
  static LiveUpdatesPlatform get instance => _instance;

  /// Platform-specific implementations should set this with their own
  /// platform-specific class that extends [LiveUpdatesPlatform] when
  /// they register themselves.
  static set instance(LiveUpdatesPlatform instance) {
    PlatformInterface.verifyToken(instance, _token);
    _instance = instance;
  }

  Future<void> showCustomNotification(Map<String, dynamic> arguments) {
    throw UnimplementedError(
        'showCustomNotification() has not been implemented.');
  }

  Future<void> showCustomCallNotification(Map<String, dynamic> arguments) {
    throw UnimplementedError(
        'showCustomCallNotification() has not been implemented.');
  }

  Future<void> showNotification(Map<String, dynamic> arguments) {
    throw UnimplementedError('showNotification() has not been implemented.');
  }

  Future<void> cancelNotification(Map<String, dynamic> arguments) {
    throw UnimplementedError('cancelNotification() has not been implemented.');
  }
}


--------------------
File: /live_updates/lib/models/live_update_progress_view.dart
--------------------

import 'package:live_updates/models/live_update_view.dart';

class LiveUpdateProgressView extends LiveUpdateView {
  final int progress;
  final int max;
  final bool indeterminate;
  final String? text;

  LiveUpdateProgressView({
    required this.progress,
    this.max = 100,
    this.indeterminate = false,
    this.text,
    required String viewId,
  }) : super(viewId: viewId);

  @override
  Map<String, dynamic> toMap() {
    return {
      'type': 'progress',
      'viewId': viewId,
      'progress': progress,
      'max': max,
      'indeterminate': indeterminate,
      'text': text,
    };
  }
}

--------------------
File: /live_updates/lib/models/live_update_style_provider.dart
--------------------

import 'dart:ui';

/// A data model for defining the style of a custom notification.
///
/// This class is intended to be used as a "style contract" between the app
/// and the plugin. The app can create a UI for users to customize these
/// properties, persist them, and then use them to dynamically construct
/// the list of `LiveUpdateView`s for `showCustomNotification`.
class LiveUpdateStyleProvider {
  /// The background color of the notification.
  final Color? backgroundColor;

  /// The color of the title text.
  final Color? titleColor;

  /// The font size of the title text.
  final double? titleSize;

  /// The color of the main content text.
  final Color? textColor;

  /// The font size of the main content text.
  final double? textSize;

  /// Creates a new instance of [LiveUpdateStyleProvider].
  LiveUpdateStyleProvider({
    this.backgroundColor,
    this.titleColor,
    this.titleSize,
    this.textColor,
    this.textSize,
  });

  /// Creates a [LiveUpdateStyleProvider] from a map.
  factory LiveUpdateStyleProvider.fromMap(Map<String, dynamic> map) {
    return LiveUpdateStyleProvider(
      backgroundColor: map['backgroundColor'] != null ? Color(map['backgroundColor']) : null,
      titleColor: map['titleColor'] != null ? Color(map['titleColor']) : null,
      titleSize: map['titleSize']?.toDouble(),
      textColor: map['textColor'] != null ? Color(map['textColor']) : null,
      textSize: map['textSize']?.toDouble(),
    );
  }

  /// Converts the [LiveUpdateStyleProvider] to a map.
  Map<String, dynamic> toMap() {
    return {
      'backgroundColor': backgroundColor?.value,
      'titleColor': titleColor?.value,
      'titleSize': titleSize,
      'textColor': textColor?.value,
      'textSize': textSize,
    };
  }
}

--------------------
File: /live_updates/lib/models/live_update_view.dart
--------------------

import 'dart:ui';
import 'dart:typed_data';

import 'package:flutter/material.dart';

// Base class for all view elements in a live update notification.
abstract class LiveUpdateView {
  final String viewId;

  LiveUpdateView({required this.viewId});

  Map<String, dynamic> toMap();
}

// Represents a text view.
class LiveUpdateTextView extends LiveUpdateView {
  final String text;
  final double fontSize;
  final Color textColor;
  final Offset position;

  LiveUpdateTextView({
    required String viewId,
    required this.text,
    this.fontSize = 14.0,
    this.textColor = Colors.black,
    required this.position,
  }) : super(viewId: viewId);

  @override
  Map<String, dynamic> toMap() {
    return {
      'type': 'textView',
      'viewId': viewId,
      'x': position.dx,
      'y': position.dy,
      'text': text,
      'fontSize': fontSize,
      'textColor': textColor.value,
    };
  }
}

// Represents a scrolling text view.
class LiveUpdateScrollingTextView extends LiveUpdateTextView {
    final int scrollSpeed;
    final double containerWidth;

    LiveUpdateScrollingTextView({
        required String viewId,
        required String text,
        double fontSize = 14.0,
        Color textColor = Colors.black,
        required Offset position,
        this.scrollSpeed = 50,
        required this.containerWidth,
    }) : super(viewId: viewId, text: text, fontSize: fontSize, textColor: textColor, position: position);

    @override
    Map<String, dynamic> toMap() {
        final map = super.toMap();
        map['type'] = 'scrollingTextView';
        map['scrollSpeed'] = scrollSpeed;
        map['containerWidth'] = containerWidth;
        return map;
    }
}


// Represents an image view.
class LiveUpdateImageView extends LiveUpdateView {
  final Uint8List? imageBytes;
  final String? imageUri;
  final double width;
  final double height;
  final Offset position;

  LiveUpdateImageView({
    required String viewId,
    this.imageBytes,
    this.imageUri,
    required this.width,
    required this.height,
    required this.position,
  })  : assert(imageBytes != null || imageUri != null, "Either imageBytes or imageUri must be provided."),
        super(viewId: viewId);

  @override
  Map<String, dynamic> toMap() {
    return {
      'type': 'imageView',
      'viewId': viewId,
      'x': position.dx,
      'y': position.dy,
      'imageBytes': imageBytes,
      'imageUri': imageUri,
      'width': width,
      'height': height,
    };
  }
}

--------------------
File: /live_updates/test/live_updates_method_channel_test.dart
--------------------

import 'package:flutter/services.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:live_updates/live_updates_method_channel.dart';

void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  MethodChannelLiveUpdates platform = MethodChannelLiveUpdates();
  const MethodChannel channel = MethodChannel('live_updates');

  setUp(() {
    TestDefaultBinaryMessengerBinding.instance.defaultBinaryMessenger.setMockMethodCallHandler(
      channel,
      (MethodCall methodCall) async {
        return '42';
      },
    );
  });

  tearDown(() {
    TestDefaultBinaryMessengerBinding.instance.defaultBinaryMessenger.setMockMethodCallHandler(channel, null);
  });

}


--------------------
File: /live_updates/test/live_updates_test.dart
--------------------

import 'package:flutter_test/flutter_test.dart';
import 'package:live_updates/live_updates.dart';
import 'package:live_updates/live_updates_platform_interface.dart';
import 'package:live_updates/live_updates_method_channel.dart';
import 'package:plugin_platform_interface/plugin_platform_interface.dart';

class MockLiveUpdatesPlatform
    with MockPlatformInterfaceMixin
    implements LiveUpdatesPlatform {
  @override
  Future<void> cancelNotification(Map<String, dynamic> arguments) {
    return Future.value();
  }

  @override
  Future<void> showCustomNotification(Map<String, dynamic> arguments) {
    return Future.value();
  }

  @override
  Future<void> showNotification(Map<String, dynamic> arguments) {
    return Future.value();
  }
}

void main() {
  final LiveUpdatesPlatform initialPlatform = LiveUpdatesPlatform.instance;

  test('$MethodChannelLiveUpdates is the default instance', () {
    expect(initialPlatform, isInstanceOf<MethodChannelLiveUpdates>());
  });
}


